const __init = Symbol();const __init2 = Symbol();import {TokenType as tt} from "./parser/tokenizer/types";


export default class NameManager {
    [__init]() {this.usedNames = new Set()}
   [__init2]() {this.symbolNames = []}

  constructor( tokens) {;this.tokens = tokens;this[__init]();this[__init2]();}

  preprocessNames() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (this.tokens.matchesAtIndex(i, [tt.name])) {
        this.usedNames.add(this.tokens.identifierNameAtIndex(i));
      }
    }
  }

  claimFreeName(name) {
    const newName = this.findFreeName(name);
    this.usedNames.add(newName);
    return newName;
  }

  findFreeName(name) {
    if (!this.usedNames.has(name)) {
      return name;
    }
    let suffixNum = 2;
    while (this.usedNames.has(name + suffixNum)) {
      suffixNum++;
    }
    return name + suffixNum;
  }

  /**
   * Get an identifier such that the identifier will be a valid reference to a symbol after codegen.
   */
  claimSymbol(name) {
    const newName = this.claimFreeName(name);
    this.symbolNames.push(newName);
    return newName;
  }

  getInjectedSymbolCode() {
    return this.symbolNames.map((name) => `const ${name} = Symbol();`).join("");
  }
}
