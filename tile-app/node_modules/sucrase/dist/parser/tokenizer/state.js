"use strict";Object.defineProperty(exports, "__esModule", {value: true});const __init = Symbol();const __init2 = Symbol();const __init3 = Symbol();const __init4 = Symbol();const __init5 = Symbol();const __init6 = Symbol();const __init7 = Symbol();const __init8 = Symbol();const __init9 = Symbol();const __init10 = Symbol();const __init11 = Symbol();
var _keywords = require('./keywords');
var _types = require('./types');

 class Scope {
  
  
  

  constructor(startTokenIndex, endTokenIndex, isFunctionScope) {
    this.startTokenIndex = startTokenIndex;
    this.endTokenIndex = endTokenIndex;
    this.isFunctionScope = isFunctionScope;
  }
} exports.Scope = Scope;

 class StateSnapshot {
  constructor(
     potentialArrowAt,
     noAnonFunctionType,
     tokensLength,
     scopesLength,
     pos,
     type,
     contextualKeyword,
     start,
     end,
     isType,
     error,
  ) {;this.potentialArrowAt = potentialArrowAt;this.noAnonFunctionType = noAnonFunctionType;this.tokensLength = tokensLength;this.scopesLength = scopesLength;this.pos = pos;this.type = type;this.contextualKeyword = contextualKeyword;this.start = start;this.end = end;this.isType = isType;this.error = error;}
} exports.StateSnapshot = StateSnapshot;

 class State {constructor() { this[__init]();this[__init2]();this[__init3]();this[__init4]();this[__init5]();this[__init6]();this[__init7]();this[__init8]();this[__init9]();this[__init10]();this[__init11](); }
  // Used to signify the start of a potential arrow function
  [__init]() {this.potentialArrowAt = -1}

  // Used by Flow to handle an edge case involving function type parsing.
  [__init2]() {this.noAnonFunctionType = false}

  // Token store.
  [__init3]() {this.tokens = []}

  // Array of all observed scopes, ordered by their ending position.
  [__init4]() {this.scopes = []}

  // The current position of the tokenizer in the input.
  [__init5]() {this.pos = 0}

  // Information about the current token.
  [__init6]() {this.type = _types.TokenType.eof}
  [__init7]() {this.contextualKeyword = _keywords.ContextualKeyword.NONE}
  [__init8]() {this.start = 0}
  [__init9]() {this.end = 0}

  [__init10]() {this.isType = false}

  /**
   * If the parser is in an error state, then the token is always tt.eof and all functions can
   * keep executing but should be written so they don't get into an infinite loop in this situation.
   *
   * This approach, combined with the ability to snapshot and restore state, allows us to implement
   * backtracking without exceptions and without needing to explicitly propagate error states
   * everywhere.
   */
  [__init11]() {this.error = null}

  snapshot() {
    return new StateSnapshot(
      this.potentialArrowAt,
      this.noAnonFunctionType,
      this.tokens.length,
      this.scopes.length,
      this.pos,
      this.type,
      this.contextualKeyword,
      this.start,
      this.end,
      this.isType,
      this.error,
    );
  }

  restoreFromSnapshot(snapshot) {
    this.potentialArrowAt = snapshot.potentialArrowAt;
    this.noAnonFunctionType = snapshot.noAnonFunctionType;
    this.tokens.length = snapshot.tokensLength;
    this.scopes.length = snapshot.scopesLength;
    this.pos = snapshot.pos;
    this.type = snapshot.type;
    this.contextualKeyword = snapshot.contextualKeyword;
    this.start = snapshot.start;
    this.end = snapshot.end;
    this.isType = snapshot.isType;
    this.error = snapshot.error;
  }
} exports.default = State;
